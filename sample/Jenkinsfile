pipeline {
    agent { label 'SSO-AGENT' }

    environment {
        PUBLISH_PORT = '10086'
        ACTIVE_PROFILE = 'dev'
        APPLICATION_NAME = 'SSO-Integration'
        FILE_NAME = 'sso-integration_master.tar'
        QA_HOST = '172.26.14.154'
        QA_USER = 'ubuntu'
        SSH_PORT = '63710'
        NETWORK_NAME = 'host'
        SONAR_CREDS=credentials('SONAR')
        IMAGE_NAME = "${APPLICATION_NAME}".toLowerCase()
        IMAGE_NAME_TAGGED_LATEST = "${IMAGE_NAME}:latest"
        E2E_IMAGE_NAME= "${APPLICATION_NAME}_e2e".toLowerCase()
        E2E_IMAGE_NAME_TAGGED_LATEST = "${E2E_IMAGE_NAME}:latest"
        SSO_WORKSPACE = "/var/jenkins/workspace/SSO-DEMO"
    }

    stages {

        stage('UNIT TEST') {
            steps {
                sh './gradlew test'
            }
        }

        stage('BUILD IMAGE') {
            steps {
                sh './gradlew clean buildImage -x test -P image_name="${IMAGE_NAME_TAGGED_LATEST}"'
            }
        }

        stage('DEPLOY TO DEV') {
            steps {
                sh "docker stop ${APPLICATION_NAME} || true && docker rm ${APPLICATION_NAME} || true"
                sh "docker images --filter=dangling=true | awk '{print \$3}'| xargs docker rmi || true "
                sh "docker run -d --name=${APPLICATION_NAME} --restart=always --net=${NETWORK_NAME} -e'APP_ENV=${ACTIVE_PROFILE}' ${IMAGE_NAME_TAGGED_LATEST}"
            }
        }

        stage('E2E TEST') {
            steps {
                sh "docker rmi ${E2E_IMAGE_NAME_TAGGED_LATEST} || true"
                sh './gradlew clean buildE2EImage -x test -P image_name="${E2E_IMAGE_NAME_TAGGED_LATEST}"'
                sh "docker run --rm ${E2E_IMAGE_NAME_TAGGED_LATEST}"
            }
        }

        stage('DEPLOY TO QA') {
            steps {
                timeout(time: 20, unit: 'SECONDS') {
                    input message: 'Approve Deploy?', ok: 'Yes'
                }

                sh "docker save -o ${FILE_NAME} ${IMAGE_NAME_TAGGED_LATEST}"

                sh "scp -P ${SSH_PORT} ${FILE_NAME} ${QA_USER}@${QA_HOST}:/home/ubuntu"

                sh "rm ${FILE_NAME}"

                sh "ssh ${QA_USER}@${QA_HOST} -p ${SSH_PORT} \"docker stop ${APPLICATION_NAME} || true && docker rm ${APPLICATION_NAME} || true && docker rmi ${IMAGE_NAME_TAGGED_LATEST} || true\""

                sh "ssh ${QA_USER}@${QA_HOST} -p ${SSH_PORT} \"docker images --filter=dangling=true | awk '{print \$3}'| xargs docker rmi || true \""

                sh "ssh ${QA_USER}@${QA_HOST} -p ${SSH_PORT} \"docker load -i ${FILE_NAME} && docker run -d --name=${APPLICATION_NAME} --restart=always --net=${NETWORK_NAME} -e'APP_ENV=qa' ${IMAGE_NAME_TAGGED_LATEST}\""
            }
        }

        stage('HEALTH CHECK') {
            steps {
                script {
                    timeout(time: 50, unit: "SECONDS") {
                        waitUntil {
                            sleep 10
                            try {
                                def responseString = sh(script: 'curl -s http://${QA_HOST}:${PUBLISH_PORT}/sso/actuator/health', returnStdout: true)
                                def response = readJSON text: responseString;
                                return response.status == "UP";
                            } catch (Exception e) {
                                return false
                            }
                        }
                    }
                }
            }
        }

        stage('API TEST') {
            steps {
                sh "scp -r -P ${SSH_PORT} ${SSO_WORKSPACE}/APITest ${QA_USER}@${QA_HOST}:/home/ubuntu"
                sh "ssh ${QA_USER}@${QA_HOST} -p ${SSH_PORT} \" cd APITest && ./gradlew clean test\""
            }
        }

        stage('SONAR ANALYSIS') {
            steps {
               sh "./gradlew sonarqube -Dsonar.host.url=http://${QA_HOST}:9000 -Dsonar.login=${SONAR_CREDS}"
            }
        }
    }
}
